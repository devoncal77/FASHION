import random
import numpy as np
import math

def makeSingleExploitOnHost(host,perm,traffic):
   return makeExploit([host,traffic],[host,perm],[host,perm+1])

def makeGeneralExploitNoChain(hosts, perms, nbT,maxH,nbEH):
    pnet = []
    pperms = []
    ts = list(range(1,nbT+1))
    maxPerm = perms[-1]
    maxH = maxH if maxH < len(hosts) else len(hosts)
    nbHosts = random.randint(1,maxH)
    hasPermUp = 0
    for i in range(0,nbHosts):
        h = random.choice(hosts)
        p = random.choice(perms)
        while [h,p] in pperms or p == maxPerm or not hasPermUp:
            h = random.choice(hosts)
            p = random.choice(perms)
            if(not hasPermUp and p!= maxPerm):
                hasPermUp = 1
        nbEH[h] = nbEH[h]+1
        pperms.append([h,p])
        # hosts.remove(h)
    for e in pperms:
        r = random.randint(0,10)
        if (r < 3):
            t = random.sample(ts,random.randint(1,nbT))
            pnet.append([e[0],t])
    hp = random.choice(pperms)
    while hp[1] == maxPerm:
        hp = random.choice(pperms)
    out = [hp[0], hp[1]+1] 
    return makeExploit(pnet,pperms,out)


def makeExploitsForHost(host, nb, maxPerm,nbTraffic):
    exploits  = []
    for i in range(0,nb) :
        trafficE = {}
        t = random.randint(0,nbTraffic)
        p = random.randint(0,maxPerm)
        if t not in trafficE.keys():
            trafficE[t] = []
        while p in trafficE[t] :
            t = random.randint(0,maxPerm)
            p = random.randint(0,maxPerm)
        trafficE[t].append(p)
        e = makeSingleExploitOnHost(host,p,nbTraffic)
        exploits.append(e)
    return exploits

def makeInfected(hosts,nbInfected):
    infected =  []
    nbHost = len(hosts)
    for i in range(0,nbInfected):
            h = random.randint(0,nbHost-1)
            while hosts[h] in infected :
                h = random.randint(0,nbHost-1)
            infected.append(hosts[h])
    return infected

def makeMultipleSizeExploit(infected,perms,nbTraffic,ebh,sizeE):
    exploits = []
    nbEH = {}
    for h in infected:
        nbEH[h] = 0
    while len(infected) :
        e = makeGeneralExploitNoChain(infected,perms,nbTraffic,sizeE,nbEH)
        exploits.append(e)
        for h in nbEH:
            try:
                if nbEH[h] >= ebh:
                    infected.remove(h)
            except ValueError:
                pass
    return exploits

def makeSingleExploits(infected,nbExploits,maxPerm,nbTraffic):
    exploits = []
    for h in infected:
        e =  makeExploitsForHost(h,nbExploits,maxPerm,nbTraffic)
        exploits.extend(e)
    return exploits


def generateExploit(hosts,percentI,nbExploits,nbExploitsByH,sizeE,maxPerm,nbTraffic,pl,single=True,ebhmode=True):
    exploits = []
    infected = []
    nbInfected = int((len(hosts) * percentI)/100)
    hosts =  list(map(int, hosts))
    nbHost = len(hosts)
    infected = makeInfected(hosts,nbInfected)
    perms = list(range(0,maxPerm))
    for i in pl:
        if int(i) in infected:
            pl[i] = maxPerm
    if(single):
        exploits = makeSingleExploits(infected,nbExploits,maxPerm,nbTraffic)
    else:
        exploits = makeMultipleSizeExploit(infected,perms,nbTraffic,nbExploitsByH,sizeE)
    return exploits


# extraH  = list  of hosts involved in external flows
# intraH = list of hosts involved in internal flows
def generateRandomConnectedExploits(intraH, extraH, hosts, percentInfectedH, nbExploits, maxPerm, nbTraffic):
    nbHosts = len(hosts)
    pool = []
    allH = intraH.union(extraH) 
    N = int((nbHosts * percentInfectedH)/100)
    if N  == 0:
        return pool
    infected = random.sample(list(allH),N) # will generate a list of N hosts include in  allH
    if len(intraH) and len(extraH): 
        while len(set(infected).intersection(intraH).intersection(extraH)) == 0:
            infected = random.sample(allH,N)
    else :
        print("WARNING: extra or intra are empty")
        infected = random.sample(hosts,N)
    nb = len(infected) * maxPerm
    half = int(nbExploits/2)
    if half > 2 or nb < nbExploits :
        # generate single exploits
        pool = generateSingleExploits(min(half,nb), infected, maxPerm, nbTraffic)
        #generate multiple exploits
        if len(infected) > 1:
            generateMultipleExploits(half if min(half,nb) == half else nbExploits - nb, infected, hosts, maxPerm, nbTraffic,  pool)
    else:
        pool = generateSingleExploits(nbExploits, infected, maxPerm, nbTraffic)
    return pool



def computeMaxMap(pool,maxPerm):
    maxmap = {}
    freeH = True
    for e in pool:
        h,pl = e["outcome"]
        if h not in maxmap:
            maxmap[h] = pl
        else:
            maxmap[h] = max(maxmap[h],pl)
    todel = []
    for h in maxmap:
        if maxmap[h]  == maxPerm:
            todel.append(h)
    if len(todel) == len(maxmap):
        freeH = False
    return (freeH,maxmap,maxmap.keys() - todel)

def generateMultipleExploits(nbExploits, infected, hosts,maxPerm, nbTraffic, pool):
    (freeH,maxMap,freeList) = computeMaxMap(pool,maxPerm)
    cond = (freeH and len(freeList) >= nbExploits/2)
    pickList = list(freeList if cond  else (infected - maxMap.keys()).union(freeList))
    pickList = list(set(hosts) - set(infected)) if len(pickList) == 0 else pickList
    while nbExploits > 0:
        cache = []
        h = random.choice(pickList)
        c = maxMap[h] if  cond else random.randint(0,maxPerm-1)
        cache.append(h)
        p = [[h,c]]
        out = [h,c+1]
        maxMap[h] = c+1
        net = []
        traffics = list(range(1,nbTraffic+1))
        netsize = random.randint(1,nbTraffic)
        net.append([h, random.sample(traffics,netsize)])
        ll = len(pickList)
        if ll > 1:
            sz = random.randint(2,min(len(pickList),3))
            phost = [h]
            while len(p) < sz :
                e = random.choice(pool)
                pe = e["prereq"]["permissions"]
                pre = random.choice(pe)
                if pre not in p and pre[0] not in phost and pre[0] not in cache:
                    p.append(pre)
                    phost.append(h)
                    cache.append(pre[0])
        ne = makeExploit(net,p,out)
        pool.append(ne)
        nbExploits -= 1

def generateSingleExploits(nbExploits, infected, maxPerm, nbTraffic):
    pool = []
    cache = []
    half = math.ceil(nbExploits/2) if nbExploits > 2 else nbExploits
    # generate 0-1 exploits
    subset = random.sample(infected,min(len(infected),half)) 
    for h in subset:
        trafics = list(range(1,nbTraffic+1))
        # netsize = random.randint(1,nbTraffic)
        net = []
        net.append([h, random.sample(trafics,1)])
        pool.append(createSingleExploit(h,net,0,maxPerm))
        nbExploits-=1
    # generate other permission escalation
    while nbExploits > 0:
        e = random.choice(pool)
        oe = e["outcome"]
        hoe = oe[0]
        ploe = oe[1]
        while oe in cache or ploe >= maxPerm:
            e = random.choice(pool)
            oe = e["outcome"]
            hoe = oe[0]
            ploe = oe[1]
        cache.append(oe)
        trafics = list(range(1,nbTraffic+1))
        # netsize = random.randint(1,nbTraffic)
        net = []
        # percent = random.randint(0,100)
        # if percent <= 30:
        net.append([hoe, random.sample(trafics,1)])
        e = createSingleExploit(oe[0],net,oe[1],maxPerm)
        pool.append(e)
        nbExploits-= 1
    return pool


def createSingleExploit(host, net, perm, maxPerm):
    if perm >= maxPerm :
        raise Exception("exploit","maxPerm reached")
    return makeExploit(net,[[host,perm]],[host,perm+1])

def makeExploit(pnet,perms,out):
    e = {}
    pre = {}
    pre["network"] = pnet
    pre["permissions"] = perms
    e["prereq"] = pre
    e["outcome"] = out
    e["prob"] = float('%.2f'%(random.random()))
    return e